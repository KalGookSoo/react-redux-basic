# 정답 및 해설

이 문서는 각 장의 확인 문제에 대한 정답과 해설을 제공합니다.

## 목차
- [Chapter 01 상태 관리 소개](#chapter-01-상태-관리-소개)
  - [01-1 상태 관리란 무엇인가](#01-1-상태-관리란-무엇인가)
  - [01-2 상태 관리의 문제점](#01-2-상태-관리의-문제점)
- [Chapter 02 Redux 기초](#chapter-02-redux-기초)
  - [02-1 Redux 소개와 아키텍처](#02-1-redux-소개와-아키텍처)
  - [02-2 Redux 핵심 개념](#02-2-redux-핵심-개념)
  - [02-3 Redux 미들웨어](#02-3-redux-미들웨어)
- [Chapter 03 Redux Toolkit 소개](#chapter-03-redux-toolkit-소개)
  - [03-1 Redux의 문제점과 Redux Toolkit의 등장](#03-1-redux의-문제점과-redux-toolkit의-등장)

## Chapter 01 상태 관리 소개

### 01-1 상태 관리란 무엇인가

#### 문제 1
**문제**: 상태(State)의 정의로 가장 적절한 것은?

**정답**: 특정 시점에서 애플리케이션의 데이터를 나타내는 객체

**해설**: 상태(State)는 특정 시점에서 애플리케이션의 데이터를 나타내는 객체입니다. 이는 사용자 입력, 서버 응답, 시간 경과에 따라 변화하는 모든 데이터를 포함합니다. UI 컴포넌트를 구성하는 요소는 상태가 아니라 상태에 의해 결정되는 결과물입니다. 서버에서 가져온 데이터는 상태의 일부일 수 있지만, 상태는 그보다 더 넓은 개념으로 클라이언트 측 데이터도 포함합니다. 사용자 인터페이스의 시각적 표현은 상태의 결과물이지 상태 자체가 아닙니다.

#### 문제 2
**문제**: 다음 중 상태 관리가 필요한 주요 이유가 아닌 것은?

**정답**: 서버와의 통신 속도 향상

**해설**: 상태 관리는 서버와의 통신 속도를 직접적으로 향상시키지 않습니다. 상태 관리의 주요 목적은 컴포넌트 간 상태 공유의 복잡성 해결, 예측 가능한 상태 변화 보장, 애플리케이션 구조 개선 및 유지보수성 향상 등입니다. 서버와의 통신 속도는 네트워크 인프라, 서버 성능, API 설계 등에 의해 주로 결정되며, 상태 관리는 이미 받아온 데이터를 효율적으로 관리하는 데 초점을 맞춥니다. 물론 상태 관리를 통해 불필요한 API 호출을 줄일 수는 있지만, 이는 통신 속도 향상이 아닌 최적화의 관점입니다.

#### 문제 3
**문제**: 효과적인 상태 관리의 이점으로 볼 수 있는 것은? (복수 응답)

**정답**: 코드 구조 개선 및 관심사 분리, 디버깅 용이성 증가, 불필요한 렌더링 방지를 통한 성능 최적화, 팀 협업 개발 향상

**해설**: 
- 코드 구조 개선 및 관심사 분리: 체계적인 상태 관리는 애플리케이션의 구조를 명확하게 하고, 상태 로직과 UI 로직을 분리하여 각 부분을 독립적으로 개발하고 테스트할 수 있게 합니다.
- 디버깅 용이성 증가: 상태 변화가 명확하고 추적 가능한 방식으로 이루어지면 버그를 더 쉽게 찾고 수정할 수 있습니다. 많은 상태 관리 라이브러리는 시간 여행 디버깅과 같은 고급 디버깅 기능을 제공합니다.
- 불필요한 렌더링 방지를 통한 성능 최적화: 효과적인 상태 관리는 상태 변화에 따른 UI 업데이트를 최적화하여 불필요한 렌더링을 방지할 수 있습니다.
- 팀 협업 개발 향상: 명확한 상태 관리 패턴은 팀 구성원 간의 협업을 개선합니다. 모든 개발자가 동일한 패턴과 규칙을 따르면 코드 이해도가 높아지고 통합이 원활해집니다.
- 서버 부하 감소: 이는 상태 관리의 직접적인 이점이 아닙니다. 서버 부하는 주로 서버 측 최적화, 캐싱 전략, 네트워크 인프라 등에 의해 결정됩니다.

### 01-2 상태 관리의 문제점

#### 문제 1
**문제**: 상태 관리에서 발생하는 주요 문제점이 아닌 것은?

**정답**: 서버와의 데이터 동기화 속도 저하

**해설**: 상태 관리의 주요 문제점은 여러 컴포넌트에서 동일한 상태를 수정할 때의 일관성 문제, 상태 간 복잡한 의존성으로 인한 관리 어려움, 상태 변경 추적 및 디버깅의 어려움 등입니다. 서버와의 데이터 동기화 속도는 상태 관리 자체의 문제가 아니라 네트워크 성능, 서버 응답 시간, API 설계 등에 의해 주로 결정됩니다. 상태 관리는 클라이언트 측에서 데이터를 어떻게 구조화하고 업데이트할지에 관한 것이며, 서버와의 통신 속도는 별개의 문제입니다.

#### 문제 2
**문제**: 다음 중 '경쟁 상태(Race Condition)'에 대한 설명으로 가장 적절한 것은?

**정답**: 여러 컴포넌트가 동시에 상태를 업데이트하려고 할 때 발생하는 문제

**해설**: 경쟁 상태(Race Condition)는 여러 컴포넌트나 프로세스가 동시에 동일한 상태를 업데이트하려고 할 때 발생하는 문제입니다. 이로 인해 마지막으로 실행된 업데이트가 이전 업데이트를 덮어쓰거나, 상태가 예측할 수 없는 값으로 변할 수 있습니다. 이는 비동기 작업이 많은 현대 웹 애플리케이션에서 특히 문제가 됩니다. 상태 업데이트의 빈도로 인한 성능 저하는 경쟁 상태가 아닌 별도의 성능 문제입니다. 순환 참조는 두 상태가 서로를 참조하는 의존성 문제이며, 컴포넌트 간 상태 전달이 많은 계층을 거치는 것은 'props drilling' 문제에 해당합니다.

#### 문제 3
**문제**: 상태 관리의 복잡성을 증가시키는 요인으로 볼 수 있는 것은? (복수 응답)

**정답**: 상태 변경 로직이 애플리케이션 전체에 분산됨, 하나의 상태 변경이 여러 파생 상태에 영향을 미침, 컴포넌트마다 다른 상태 관리 패턴 사용, 상태 변경에 따른 부작용(Side Effects) 발생

**해설**: 
- 상태 변경 로직이 애플리케이션 전체에 분산됨: 상태 변경 로직이 여러 컴포넌트에 분산되면 어떤 컴포넌트가 어떤 상태를 변경하는지 추적하기 어려워지고, 코드 중복과 일관성 문제가 발생할 수 있습니다.
- 하나의 상태 변경이 여러 파생 상태에 영향을 미침: 상태 간 복잡한 의존성은 예측하기 어려운 상태 변화를 초래하고, 이러한 의존성을 관리하는 것은 매우 복잡합니다.
- 컴포넌트마다 다른 상태 관리 패턴 사용: 일관된 패턴 없이 각 컴포넌트가 다른 방식으로 상태를 관리하면 코드 이해와 유지보수가 어려워집니다.
- 상태 변경에 따른 부작용(Side Effects) 발생: 상태 변경이 로컬 스토리지 업데이트, API 호출 등 다양한 부작용을 트리거하면 이러한 연쇄 반응을 추적하고 디버깅하기 어려워집니다.
- 컴포넌트의 재사용성 증가: 이는 상태 관리의 복잡성을 증가시키는 요인이 아니라 오히려 잘 설계된 상태 관리 시스템의 이점입니다. 컴포넌트가 상태 로직과 분리되어 있으면 재사용성이 향상됩니다.

### 02-1 Redux 소개와 아키텍처

#### 문제 1
**문제**: Redux 아키텍처의 핵심 원칙이 아닌 것은?

**정답**: 양방향 데이터 바인딩(Two-way Data Binding)

**해설**: Redux의 핵심 원칙은 단일 진리의 원천(Single Source of Truth), 상태는 읽기 전용(State is Read-Only), 변경은 순수 함수로 작성(Changes are Made with Pure Functions)입니다. 양방향 데이터 바인딩은 Redux의 원칙이 아니라 오히려 그 반대입니다. Redux는 단방향 데이터 흐름을 따르며, 이는 데이터가 항상 액션 → 리듀서 → 스토어 → 뷰의 한 방향으로만 흐르도록 합니다. 양방향 데이터 바인딩은 Angular와 같은 프레임워크에서 사용되는 패턴으로, 모델과 뷰가 서로 직접적으로 영향을 주고받는 방식입니다.

#### 문제 2
**문제**: Redux의 데이터 흐름 순서로 올바른 것은?

**정답**: 액션 → 리듀서 → 스토어 → 뷰

**해설**: Redux의 데이터 흐름은 단방향으로, 액션이 발행되면 리듀서가 이를 처리하여 새로운 상태를 계산하고, 이 상태가 스토어에 저장된 후 뷰(컴포넌트)에 전달되어 UI가 업데이트됩니다. 이러한 단방향 데이터 흐름은 상태 변화를 예측 가능하게 만들고 디버깅을 용이하게 합니다. 다른 보기들은 모두 잘못된 순서를 나타냅니다. 특히 Redux에서는 스토어가 액션을 발행하지 않으며, 뷰가 직접 스토어를 수정하지도 않습니다.

#### 문제 3
**문제**: Redux를 사용하는 것이 적합한 경우는? (복수 응답)

**정답**: 애플리케이션의 여러 부분에서 공유해야 하는 상당한 양의 상태가 있는 경우, 상태 업데이트 로직이 복잡한 경우, 상태 변경 내역을 추적해야 하는 경우

**해설**: 
- 애플리케이션의 여러 부분에서 공유해야 하는 상당한 양의 상태가 있는 경우: Redux는 중앙 집중식 상태 관리를 제공하므로, 여러 컴포넌트에서 공유해야 하는 상태가 많을 때 유용합니다.
- 상태 업데이트 로직이 복잡한 경우: Redux의 리듀서 패턴은 복잡한 상태 업데이트 로직을 관리하는 데 도움이 됩니다.
- 상태 변경 내역을 추적해야 하는 경우: Redux DevTools를 사용하면 모든 상태 변경을 추적하고 시간 여행 디버깅을 할 수 있습니다.
- 모든 소규모 애플리케이션: 소규모 애플리케이션에서는 Redux가 오히려 불필요한 복잡성을 추가할 수 있으므로 적합하지 않을 수 있습니다.
- 단순한 폼 상태만 관리하는 경우: 단순한 폼 상태는 로컬 컴포넌트 상태나 React의 Context API로 충분히 관리할 수 있으므로, Redux를 사용하는 것은 과도할 수 있습니다.

### 02-2 Redux 핵심 개념

#### 문제 1
**문제**: Redux에서 상태 변경을 일으키는 유일한 방법은 무엇인가요?

**정답**: 액션을 디스패치하기

**해설**: Redux에서 상태 변경을 일으키는 유일한 방법은 액션을 디스패치하는 것입니다. 액션은 상태 변경을 설명하는 정보 패킷으로, 디스패치 과정을 통해 스토어로 전달됩니다. 리듀서 함수를 직접 호출하거나 스토어의 상태를 직접 수정하는 것은 Redux의 원칙에 어긋납니다. 셀렉터 함수는 상태에서 데이터를 추출하는 용도로 사용되며, 상태 변경과는 관련이 없습니다. Redux의 단방향 데이터 흐름에서 상태 변경은 항상 액션 발행으로 시작되어 리듀서를 통해 처리됩니다.

#### 문제 2
**문제**: 다음 중 리듀서(Reducer)의 특징으로 올바르지 않은 것은?

**정답**: 비동기 작업을 직접 처리할 수 있다

**해설**: 리듀서는 순수 함수여야 하므로 비동기 작업을 직접 처리할 수 없습니다. 순수 함수는 동일한 입력에 대해 항상 동일한 출력을 반환하고, 부작용(side effects)이 없어야 합니다. 비동기 작업은 부작용을 발생시키므로 리듀서 내에서 직접 처리할 수 없습니다. Redux에서 비동기 작업은 미들웨어(예: redux-thunk, redux-saga)를 통해 처리됩니다. 리듀서는 이전 상태를 변경하지 않고 새로운 상태를 반환하며(불변성 유지), 동일한 입력에 대해 항상 동일한 출력을 반환하는 예측 가능한 함수여야 합니다.

#### 문제 3
**문제**: Redux의 핵심 구성 요소로 올바른 것은? (복수 응답)

**정답**: 액션(Action), 리듀서(Reducer), 스토어(Store), 디스패치(Dispatch)

**해설**: 
- 액션(Action): 상태 변경을 설명하는 정보 패킷으로, type 속성을 필수로 가지며 상태 변경에 필요한 데이터를 포함합니다.
- 리듀서(Reducer): 현재 상태와 액션을 받아 새로운 상태를 반환하는 순수 함수로, 상태 변경 로직을 담당합니다.
- 스토어(Store): 애플리케이션의 전체 상태를 보관하는 객체로, 상태 접근, 업데이트, 변경 구독 기능을 제공합니다.
- 디스패치(Dispatch): 액션을 스토어로 보내는 과정으로, 상태 변경을 트리거하는 유일한 방법입니다.
- 옵저버(Observer): 이는 Redux의 핵심 구성 요소가 아닙니다. Redux에서는 '구독자(Subscriber)'라는 개념이 있지만, 이는 상태 변경을 감지하기 위한 메커니즘으로, 핵심 구성 요소라기보다는 스토어의 기능 중 하나입니다.

### 02-3 Redux 미들웨어

#### 문제 1
**문제**: Redux 미들웨어의 주요 역할은 무엇인가요?

**정답**: 액션이 디스패치되어 리듀서에 도달하기 전에 가로채서 추가 작업 수행하기

**해설**: Redux 미들웨어는 액션이 디스패치되어 리듀서에 도달하기 전에 가로채서 추가 작업을 수행할 수 있게 해주는 확장 포인트입니다. 미들웨어는 로깅, 비동기 API 호출, 에러 처리 등 다양한 부수 효과(side effects)를 처리하는 데 사용됩니다. 리듀서 함수 최적화는 미들웨어의 주요 역할이 아니며, 리듀서는 순수 함수로 유지되어야 합니다. 스토어의 상태를 직접 수정하는 것은 Redux의 원칙에 어긋나며, 컴포넌트 렌더링 성능 향상은 미들웨어의 주요 목적이 아닙니다.

#### 문제 2
**문제**: 다음 중 Redux Thunk에 대한 설명으로 올바른 것은?

**정답**: 액션 생성자가 액션 객체 대신 함수를 반환할 수 있게 해준다

**해설**: Redux Thunk는 액션 생성자가 일반 액션 객체 대신 함수를 반환할 수 있게 해주는 미들웨어입니다. 이 함수는 `dispatch`와 `getState`를 인자로 받아 비동기 작업을 수행하고, 작업이 완료되면 액션을 디스패치할 수 있습니다. 제너레이터 함수를 사용하여 비동기 작업을 관리하는 것은 Redux Saga의 특징이며, RxJS를 기반으로 한 반응형 프로그래밍 방식은 Redux Observable의 특징입니다. 미들웨어 없이도 비동기 작업을 처리할 수는 있지만, 이는 컴포넌트에 비동기 로직이 포함되어 코드 중복, 테스트 어려움 등의 문제를 야기합니다.

#### 문제 3
**문제**: 다음 중 Redux 미들웨어를 사용하는 이유로 적절한 것은? (복수 응답)

**정답**: 비동기 API 호출 처리, 액션 로깅 및 디버깅, 리듀서의 순수성 유지

**해설**: 
- 비동기 API 호출 처리: 미들웨어는 API 호출과 같은 비동기 작업을 처리하는 데 이상적입니다. 특히 Redux Thunk, Redux Saga 등은 이러한 목적으로 설계되었습니다.
- 액션 로깅 및 디버깅: 미들웨어를 사용하면 모든 액션과 상태 변화를 로깅하여 디버깅을 용이하게 할 수 있습니다.
- 리듀서의 순수성 유지: 미들웨어는 부수 효과를 리듀서 외부로 분리하여 리듀서가 순수 함수로 유지되도록 합니다.
- 컴포넌트 간 상태 공유: 이는 미들웨어의 주요 목적이 아니라 Redux 스토어 자체의 역할입니다.
- 복잡한 상태 변환 로직 구현: 이는 주로 리듀서의 역할이며, 미들웨어는 상태 변환 자체보다는 부수 효과 처리에 중점을 둡니다.

## Chapter 03 Redux Toolkit 소개

### 03-1 Redux의 문제점과 Redux Toolkit의 등장

#### 문제 1
**문제**: Redux Toolkit이 등장하게 된 주요 배경은 무엇인가요?

**정답**: 과도한 보일러플레이트 코드와 복잡한 설정 문제 해결

**해설**: Redux Toolkit은 기존 Redux 사용 시 발생하는 과도한 보일러플레이트 코드와 복잡한 설정 문제를 해결하기 위해 등장했습니다. Redux는 강력한 상태 관리 라이브러리지만, 간단한 기능을 구현하는 데도 액션 타입, 액션 생성자, 리듀서 등 많은 코드가 필요했고, 스토어 설정, 미들웨어 적용, 개발 도구 연결 등의 설정이 복잡했습니다. Redux Toolkit은 이러한 문제를 해결하고 개발자 경험을 개선하기 위해 Redux 팀에서 공식적으로 개발한 도구 모음입니다. Redux의 성능 문제나 React와의 호환성 문제, 모바일 환경 최적화 문제는 Redux Toolkit 등장의 주요 배경이 아닙니다.

#### 문제 2
**문제**: Redux Toolkit의 `createSlice` API가 제공하는 주요 이점은 무엇인가요?

**정답**: 액션 타입, 액션 생성자, 리듀서를 한 번에 생성한다

**해설**: Redux Toolkit의 `createSlice` API는 액션 타입, 액션 생성자, 리듀서를 한 번에 생성하는 기능을 제공합니다. 이를 통해 개발자는 보일러플레이트 코드를 크게 줄일 수 있습니다. 기존 Redux에서는 이러한 요소들을 각각 별도로 정의해야 했지만, `createSlice`를 사용하면 하나의 객체 안에서 모든 것을 정의할 수 있습니다. 상태의 불변성을 자동으로 처리하는 것은 `createSlice`의 기능이기도 하지만, 이는 내부적으로 Immer 라이브러리를 사용하기 때문이며 주요 이점은 코드 간소화입니다. 비동기 작업 자동 처리는 `createAsyncThunk`의 역할이고, 컴포넌트와 스토어 자동 연결은 Redux Toolkit의 기능이 아닙니다.

#### 문제 3
**문제**: Redux Toolkit이 기존 Redux와 비교하여 개선한 부분은 무엇인가요? (복수 응답)

**정답**: 보일러플레이트 코드 감소, 불변성 관리 자동화, 비동기 로직 처리 간소화, 타입 안전성 강화, 스토어 설정 간소화

**해설**: 
- 보일러플레이트 코드 감소: `createSlice` API를 통해 액션 타입, 액션 생성자, 리듀서를 한 번에 생성하여 코드량을 크게 줄였습니다.
- 불변성 관리 자동화: Immer 라이브러리를 내부적으로 사용하여 개발자가 마치 상태를 직접 변경하는 것처럼 코드를 작성할 수 있지만, 실제로는 불변성이 유지됩니다.
- 비동기 로직 처리 간소화: `createAsyncThunk`를 통해 비동기 작업을 더 쉽게 처리할 수 있으며, 로딩, 성공, 실패 상태를 자동으로 처리해줍니다.
- 타입 안전성 강화: TypeScript와의 통합이 개선되어 타입 안전성을 높일 수 있습니다.
- 스토어 설정 간소화: `configureStore`를 통해 스토어 설정을 간소화하고, 개발 도구와 미들웨어를 자동으로 설정할 수 있습니다.

모든 선택지가 Redux Toolkit이 기존 Redux와 비교하여 개선한 부분에 해당합니다.

### 03-2 Redux Toolkit의 주요 기능

#### 문제 1
**문제**: Redux Toolkit의 `configureStore` 함수가 자동으로 설정하는 것은 무엇인가요?

**정답**: Redux DevTools Extension 연결

**해설**: Redux Toolkit의 `configureStore` 함수는 Redux DevTools Extension을 자동으로 연결하여 개발자가 별도의 설정 없이도 강력한 디버깅 도구를 사용할 수 있게 해줍니다. 또한 기본 미들웨어(redux-thunk 포함)를 자동으로 설정하고, 개발 환경에서의 오류 검사 기능도 제공합니다. 이를 통해 기존 Redux의 복잡한 스토어 설정 과정을 크게 간소화할 수 있습니다. 컴포넌트와 스토어 연결은 React-Redux 라이브러리의 역할이며, 리듀서 함수 생성은 `createSlice`의 역할입니다. 상태의 불변성 처리는 Immer 라이브러리를 통해 `createSlice` 내부에서 이루어집니다.

#### 문제 2
**문제**: Redux Toolkit의 `createSlice`가 제공하는 기능이 아닌 것은 무엇인가요?

**정답**: API 요청 자동 처리

**해설**: Redux Toolkit의 `createSlice`는 액션 타입 자동 생성, 액션 생성자 자동 생성, 리듀서 함수 자동 생성 기능을 제공하지만, API 요청 자동 처리 기능은 제공하지 않습니다. API 요청과 같은 비동기 작업은 `createAsyncThunk`나 RTK Query를 통해 처리됩니다. `createSlice`는 주로 동기적인 상태 업데이트 로직을 간소화하는 데 중점을 두고 있으며, 내부적으로 Immer 라이브러리를 사용하여 불변성을 자동으로 처리합니다. 이를 통해 개발자는 보일러플레이트 코드를 크게 줄이고 더 직관적인 방식으로 상태 업데이트 로직을 작성할 수 있습니다.

#### 문제 3
**문제**: Redux Toolkit에서 비동기 작업을 처리하는 방법으로 올바른 것은 무엇인가요? (복수 응답)

**정답**: `createAsyncThunk` 사용, `RTK Query` 사용, `extraReducers`에서 비동기 액션 처리

**해설**: 
- `createAsyncThunk` 사용: 이 API는 비동기 작업의 생명주기(pending, fulfilled, rejected)를 자동으로 관리하고, 해당 상태에 따른 액션을 디스패치합니다.
- `RTK Query` 사용: 데이터 가져오기 및 캐싱을 위한 강력한 도구로, API 통신을 위한 보일러플레이트 코드를 크게 줄이고 자동 캐싱, 로딩 상태 관리 등의 기능을 제공합니다.
- `extraReducers`에서 비동기 액션 처리: `createSlice`의 `extraReducers` 필드를 사용하여 `createAsyncThunk`로 생성된 비동기 액션의 상태(pending, fulfilled, rejected)에 따른 리듀서 로직을 정의할 수 있습니다.
- `createSlice`의 `asyncReducers` 속성 사용: 이는 존재하지 않는 속성입니다. Redux Toolkit에는 `asyncReducers`라는 속성이 없습니다.
- `configureStore`의 `asyncMiddleware` 설정 사용: 이 역시 존재하지 않는 설정입니다. `configureStore`에는 `middleware` 설정이 있지만, `asyncMiddleware`라는 특정 설정은 없습니다.

#### 문제 4
**문제**: Redux Toolkit의 `createEntityAdapter`가 제공하는 기능은 무엇인가요? (복수 응답)

**정답**: 정규화된 데이터 구조 자동 관리, 엔티티 조작을 위한 표준 CRUD 작업 제공, 엔티티 선택을 위한 메모이제이션된 선택자 함수 제공

**해설**: 
- 정규화된 데이터 구조 자동 관리: `createEntityAdapter`는 `{ ids: [], entities: {} }` 형태의 정규화된 데이터 구조를 자동으로 생성하고 관리합니다.
- 엔티티 조작을 위한 표준 CRUD 작업 제공: `addOne`, `addMany`, `updateOne`, `removeOne` 등의 표준화된 CRUD 작업을 제공하여 엔티티 데이터를 쉽게 조작할 수 있게 합니다.
- 엔티티 선택을 위한 메모이제이션된 선택자 함수 제공: `selectAll`, `selectById`, `selectIds` 등의 메모이제이션된 선택자 함수를 제공하여 엔티티 데이터를 효율적으로 조회할 수 있게 합니다.
- 엔티티 데이터의 자동 캐싱: 이는 `createEntityAdapter`의 기능이 아니라 RTK Query의 기능입니다.
- 엔티티 데이터의 자동 직렬화/역직렬화: 이 역시 `createEntityAdapter`의 기능이 아닙니다. Redux Toolkit은 `serializableCheck` 미들웨어를 통해 직렬화 가능성을 검사할 수는 있지만, 자동 직렬화/역직렬화 기능은 제공하지 않습니다.

### 03-3 Redux Toolkit 실전 활용 사례

#### 문제 1
**문제**: Redux Toolkit을 사용한 사용자 인증 관리에서 로그인 상태를 유지하기 위한 적절한 방법은?

**정답**: 로컬 스토리지에 토큰 저장 후 Redux 상태와 동기화

**해설**: 사용자 인증 관리에서 로그인 상태를 유지하기 위한 가장 적절한 방법은 로컬 스토리지에 토큰을 저장하고 이를 Redux 상태와 동기화하는 것입니다. 이 방식은 페이지 새로고침이나 브라우저 종료 후 재방문 시에도 사용자의 로그인 상태를 유지할 수 있게 해줍니다. 초기 상태에서 로컬 스토리지의 토큰을 확인하여 인증 상태를 설정하고, 로그인/로그아웃 시 로컬 스토리지와 Redux 상태를 함께 업데이트하는 패턴이 일반적입니다. 브라우저 쿠키는 보안에 취약할 수 있고, 세션 스토리지는 브라우저 종료 시 데이터가 삭제되며, Redux 상태만 사용하면 페이지 새로고침 시 상태가 초기화되는 단점이 있습니다.

#### 문제 2
**문제**: RTK Query의 주요 이점이 아닌 것은?

**정답**: 상태 변경 내역 자동 기록

**해설**: RTK Query의 주요 이점에는 자동 캐싱 및 중복 요청 방지, 로딩/성공/실패 상태 자동 관리, 태그 기반 캐시 무효화 등이 있지만, 상태 변경 내역 자동 기록은 RTK Query의 기능이 아닙니다. 상태 변경 내역 기록은 Redux DevTools의 기능으로, Redux 상태의 모든 변경을 추적하고 시간 여행 디버깅을 가능하게 합니다. RTK Query는 주로 서버 데이터 가져오기, 캐싱, 업데이트에 초점을 맞추고 있으며, 데이터 페칭 로직을 선언적으로 정의하고 React 컴포넌트에서 쉽게 사용할 수 있는 훅을 자동으로 생성해주는 기능을 제공합니다.

#### 문제 3
**문제**: Redux Toolkit의 createEntityAdapter를 사용하는 주요 이유로 올바른 것은? (복수 응답)

**정답**: 정규화된 데이터 구조 자동 관리, 엔티티 조작을 위한 표준 CRUD 작업 제공, 엔티티 선택을 위한 메모이제이션된 선택자 함수 제공

**해설**: 
- 정규화된 데이터 구조 자동 관리: createEntityAdapter는 `{ ids: [], entities: {} }` 형태의 정규화된 데이터 구조를 자동으로 생성하고 관리하여 데이터 접근 효율성을 높입니다.
- 엔티티 조작을 위한 표준 CRUD 작업 제공: addOne, addMany, updateOne, removeOne 등의 표준화된 CRUD 작업을 제공하여 엔티티 데이터를 일관된 방식으로 쉽게 조작할 수 있게 합니다.
- 엔티티 선택을 위한 메모이제이션된 선택자 함수 제공: selectAll, selectById, selectIds 등의 메모이제이션된 선택자 함수를 제공하여 성능 최적화된 방식으로 엔티티 데이터를 조회할 수 있게 합니다.
- 비동기 작업 자동 처리: 이는 createEntityAdapter의 기능이 아니라 createAsyncThunk나 RTK Query의 기능입니다.
- 컴포넌트와 스토어 자동 연결: 이 역시 createEntityAdapter의 기능이 아니라 React-Redux의 connect 함수나 useSelector, useDispatch 훅의 기능입니다.

#### 문제 1
**문제**: Redux Toolkit의 `configureStore` 함수가 자동으로 설정하는 것은 무엇인가요?

**정답**: Redux DevTools Extension 연결

**해설**: Redux Toolkit의 `configureStore` 함수는 Redux DevTools Extension을 자동으로 연결하여 개발자가 별도의 설정 없이도 강력한 디버깅 도구를 사용할 수 있게 해줍니다. 또한 기본 미들웨어(redux-thunk 포함)를 자동으로 설정하고, 개발 환경에서의 오류 검사 기능도 제공합니다. 이를 통해 기존 Redux의 복잡한 스토어 설정 과정을 크게 간소화할 수 있습니다. 컴포넌트와 스토어 연결은 React-Redux 라이브러리의 역할이며, 리듀서 함수 생성은 `createSlice`의 역할입니다. 상태의 불변성 처리는 Immer 라이브러리를 통해 `createSlice` 내부에서 이루어집니다.

#### 문제 2
**문제**: Redux Toolkit의 `createSlice`가 제공하는 기능이 아닌 것은 무엇인가요?

**정답**: API 요청 자동 처리

**해설**: Redux Toolkit의 `createSlice`는 액션 타입 자동 생성, 액션 생성자 자동 생성, 리듀서 함수 자동 생성 기능을 제공하지만, API 요청 자동 처리 기능은 제공하지 않습니다. API 요청과 같은 비동기 작업은 `createAsyncThunk`나 RTK Query를 통해 처리됩니다. `createSlice`는 주로 동기적인 상태 업데이트 로직을 간소화하는 데 중점을 두고 있으며, 내부적으로 Immer 라이브러리를 사용하여 불변성을 자동으로 처리합니다. 이를 통해 개발자는 보일러플레이트 코드를 크게 줄이고 더 직관적인 방식으로 상태 업데이트 로직을 작성할 수 있습니다.

#### 문제 3
**문제**: Redux Toolkit에서 비동기 작업을 처리하는 방법으로 올바른 것은 무엇인가요? (복수 응답)

**정답**: `createAsyncThunk` 사용, `RTK Query` 사용, `extraReducers`에서 비동기 액션 처리

**해설**: 
- `createAsyncThunk` 사용: 이 API는 비동기 작업의 생명주기(pending, fulfilled, rejected)를 자동으로 관리하고, 해당 상태에 따른 액션을 디스패치합니다.
- `RTK Query` 사용: 데이터 가져오기 및 캐싱을 위한 강력한 도구로, API 통신을 위한 보일러플레이트 코드를 크게 줄이고 자동 캐싱, 로딩 상태 관리 등의 기능을 제공합니다.
- `extraReducers`에서 비동기 액션 처리: `createSlice`의 `extraReducers` 필드를 사용하여 `createAsyncThunk`로 생성된 비동기 액션의 상태(pending, fulfilled, rejected)에 따른 리듀서 로직을 정의할 수 있습니다.
- `createSlice`의 `asyncReducers` 속성 사용: 이는 존재하지 않는 속성입니다. Redux Toolkit에는 `asyncReducers`라는 속성이 없습니다.
- `configureStore`의 `asyncMiddleware` 설정 사용: 이 역시 존재하지 않는 설정입니다. `configureStore`에는 `middleware` 설정이 있지만, `asyncMiddleware`라는 특정 설정은 없습니다.

#### 문제 4
**문제**: Redux Toolkit의 `createEntityAdapter`가 제공하는 기능은 무엇인가요? (복수 응답)

**정답**: 정규화된 데이터 구조 자동 관리, 엔티티 조작을 위한 표준 CRUD 작업 제공, 엔티티 선택을 위한 메모이제이션된 선택자 함수 제공

**해설**: 
- 정규화된 데이터 구조 자동 관리: `createEntityAdapter`는 `{ ids: [], entities: {} }` 형태의 정규화된 데이터 구조를 자동으로 생성하고 관리합니다.
- 엔티티 조작을 위한 표준 CRUD 작업 제공: `addOne`, `addMany`, `updateOne`, `removeOne` 등의 표준화된 CRUD 작업을 제공하여 엔티티 데이터를 쉽게 조작할 수 있게 합니다.
- 엔티티 선택을 위한 메모이제이션된 선택자 함수 제공: `selectAll`, `selectById`, `selectIds` 등의 메모이제이션된 선택자 함수를 제공하여 엔티티 데이터를 효율적으로 조회할 수 있게 합니다.
- 엔티티 데이터의 자동 캐싱: 이는 `createEntityAdapter`의 기능이 아니라 RTK Query의 기능입니다.
- 엔티티 데이터의 자동 직렬화/역직렬화: 이 역시 `createEntityAdapter`의 기능이 아닙니다. Redux Toolkit은 `serializableCheck` 미들웨어를 통해 직렬화 가능성을 검사할 수는 있지만, 자동 직렬화/역직렬화 기능은 제공하지 않습니다.

